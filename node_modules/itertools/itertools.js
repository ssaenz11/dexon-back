"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.chain = chain;
exports.count = count;
exports.compress = compress;
exports.cycle = cycle;
exports.dropwhile = dropwhile;
exports.groupby = groupby;
exports.icompress = icompress;
exports.ifilter = ifilter;
exports.imap = imap;
exports.islice = islice;
exports.izip2 = izip2;
exports.izip3 = izip3;
exports.izipLongest2 = izipLongest2;
exports.izipLongest3 = izipLongest3;
exports.izipMany = izipMany;
exports.permutations = permutations;
exports.repeat = repeat;
exports.takewhile = takewhile;
exports.zipLongest2 = zipLongest2;
exports.zipLongest3 = zipLongest3;
exports.zipMany = zipMany;
exports.zipLongest = exports.izipLongest = exports.izip = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _builtins = require("./builtins");

var _moreItertools = require("./more-itertools");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _marked =
/*#__PURE__*/
_regenerator["default"].mark(count),
    _marked2 =
/*#__PURE__*/
_regenerator["default"].mark(cycle),
    _marked3 =
/*#__PURE__*/
_regenerator["default"].mark(dropwhile),
    _marked4 =
/*#__PURE__*/
_regenerator["default"].mark(groupby),
    _marked5 =
/*#__PURE__*/
_regenerator["default"].mark(icompress),
    _marked6 =
/*#__PURE__*/
_regenerator["default"].mark(ifilter),
    _marked7 =
/*#__PURE__*/
_regenerator["default"].mark(imap),
    _marked8 =
/*#__PURE__*/
_regenerator["default"].mark(islice),
    _marked9 =
/*#__PURE__*/
_regenerator["default"].mark(izip2),
    _marked10 =
/*#__PURE__*/
_regenerator["default"].mark(izip3),
    _marked11 =
/*#__PURE__*/
_regenerator["default"].mark(izipLongest2),
    _marked12 =
/*#__PURE__*/
_regenerator["default"].mark(izipLongest3),
    _marked13 =
/*#__PURE__*/
_regenerator["default"].mark(izipMany),
    _marked14 =
/*#__PURE__*/
_regenerator["default"].mark(permutations),
    _marked15 =
/*#__PURE__*/
_regenerator["default"].mark(repeat),
    _marked16 =
/*#__PURE__*/
_regenerator["default"].mark(takewhile);

var SENTINEL = Symbol();

function composeAnd(f1, f2) {
  return function (n) {
    return f1(n) && f2(n);
  };
}

function slicePredicate(start, stop, step) {
  // If stop is not provided (= undefined), then interpret the start value as the stop value
  var _start = start,
      _stop = stop,
      _step = step;

  if (_stop === undefined) {
    var _ref = [0, _start];
    _start = _ref[0];
    _stop = _ref[1];
  }

  var pred = function pred(n) {
    return n >= _start;
  };

  if (_stop !== null) {
    var stopNotNull = _stop;
    pred = composeAnd(pred, function (n) {
      return n < stopNotNull;
    });
  }

  if (_step > 1) {
    pred = composeAnd(pred, function (n) {
      return (n - _start) % _step === 0;
    });
  }

  return pred;
}
/**
 * Returns an iterator that returns elements from the first iterable until it
 * is exhausted, then proceeds to the next iterable, until all of the iterables
 * are exhausted.  Used for treating consecutive sequences as a single
 * sequence.
 */


function chain() {
  for (var _len = arguments.length, iterables = new Array(_len), _key = 0; _key < _len; _key++) {
    iterables[_key] = arguments[_key];
  }

  return (0, _moreItertools.flatten)(iterables);
}
/**
 * Returns an iterator that counts up values starting with number `start`
 * (default 0), incrementing by `step`.  To decrement, use a negative step
 * number.
 */


function count() {
  var start,
      step,
      n,
      _args = arguments;
  return _regenerator["default"].wrap(function count$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          start = _args.length > 0 && _args[0] !== undefined ? _args[0] : 0;
          step = _args.length > 1 && _args[1] !== undefined ? _args[1] : 1;
          n = start;

        case 3:
          _context.next = 5;
          return n;

        case 5:
          n += step;

        case 6:
          _context.next = 3;
          break;

        case 8:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}
/**
 * Non-lazy version of icompress().
 */


function compress(data, selectors) {
  return Array.from(icompress(data, selectors));
}
/**
 * Returns an iterator producing elements from the iterable and saving a copy
 * of each.  When the iterable is exhausted, return elements from the saved
 * copy.  Repeats indefinitely.
 */


function cycle(iterable) {
  var saved, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step2, _element, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step3, element;

  return _regenerator["default"].wrap(function cycle$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          saved = [];
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context2.prev = 4;
          _iterator = iterable[Symbol.iterator]();

        case 6:
          if (_iteratorNormalCompletion = (_step2 = _iterator.next()).done) {
            _context2.next = 14;
            break;
          }

          _element = _step2.value;
          _context2.next = 10;
          return _element;

        case 10:
          saved.push(_element);

        case 11:
          _iteratorNormalCompletion = true;
          _context2.next = 6;
          break;

        case 14:
          _context2.next = 20;
          break;

        case 16:
          _context2.prev = 16;
          _context2.t0 = _context2["catch"](4);
          _didIteratorError = true;
          _iteratorError = _context2.t0;

        case 20:
          _context2.prev = 20;
          _context2.prev = 21;

          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }

        case 23:
          _context2.prev = 23;

          if (!_didIteratorError) {
            _context2.next = 26;
            break;
          }

          throw _iteratorError;

        case 26:
          return _context2.finish(23);

        case 27:
          return _context2.finish(20);

        case 28:
          if (!(saved.length > 0)) {
            _context2.next = 57;
            break;
          }

          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context2.prev = 32;
          _iterator2 = saved[Symbol.iterator]();

        case 34:
          if (_iteratorNormalCompletion2 = (_step3 = _iterator2.next()).done) {
            _context2.next = 41;
            break;
          }

          element = _step3.value;
          _context2.next = 38;
          return element;

        case 38:
          _iteratorNormalCompletion2 = true;
          _context2.next = 34;
          break;

        case 41:
          _context2.next = 47;
          break;

        case 43:
          _context2.prev = 43;
          _context2.t1 = _context2["catch"](32);
          _didIteratorError2 = true;
          _iteratorError2 = _context2.t1;

        case 47:
          _context2.prev = 47;
          _context2.prev = 48;

          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }

        case 50:
          _context2.prev = 50;

          if (!_didIteratorError2) {
            _context2.next = 53;
            break;
          }

          throw _iteratorError2;

        case 53:
          return _context2.finish(50);

        case 54:
          return _context2.finish(47);

        case 55:
          _context2.next = 28;
          break;

        case 57:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, null, [[4, 16, 20, 28], [21,, 23, 27], [32, 43, 47, 55], [48,, 50, 54]]);
}
/**
 * Returns an iterator that drops elements from the iterable as long as the
 * predicate is true; afterwards, returns every remaining element.  Note, the
 * iterator does not produce any output until the predicate first becomes
 * false.
 */


function dropwhile(iterable, predicate) {
  var it, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step4, value, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step5, _value;

  return _regenerator["default"].wrap(function dropwhile$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          it = (0, _builtins.iter)(iterable);
          _iteratorNormalCompletion3 = true;
          _didIteratorError3 = false;
          _iteratorError3 = undefined;
          _context3.prev = 4;
          _iterator3 = it[Symbol.iterator]();

        case 6:
          if (_iteratorNormalCompletion3 = (_step4 = _iterator3.next()).done) {
            _context3.next = 15;
            break;
          }

          value = _step4.value;

          if (predicate(value)) {
            _context3.next = 12;
            break;
          }

          _context3.next = 11;
          return value;

        case 11:
          return _context3.abrupt("break", 15);

        case 12:
          _iteratorNormalCompletion3 = true;
          _context3.next = 6;
          break;

        case 15:
          _context3.next = 21;
          break;

        case 17:
          _context3.prev = 17;
          _context3.t0 = _context3["catch"](4);
          _didIteratorError3 = true;
          _iteratorError3 = _context3.t0;

        case 21:
          _context3.prev = 21;
          _context3.prev = 22;

          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }

        case 24:
          _context3.prev = 24;

          if (!_didIteratorError3) {
            _context3.next = 27;
            break;
          }

          throw _iteratorError3;

        case 27:
          return _context3.finish(24);

        case 28:
          return _context3.finish(21);

        case 29:
          _iteratorNormalCompletion4 = true;
          _didIteratorError4 = false;
          _iteratorError4 = undefined;
          _context3.prev = 32;
          _iterator4 = it[Symbol.iterator]();

        case 34:
          if (_iteratorNormalCompletion4 = (_step5 = _iterator4.next()).done) {
            _context3.next = 41;
            break;
          }

          _value = _step5.value;
          _context3.next = 38;
          return _value;

        case 38:
          _iteratorNormalCompletion4 = true;
          _context3.next = 34;
          break;

        case 41:
          _context3.next = 47;
          break;

        case 43:
          _context3.prev = 43;
          _context3.t1 = _context3["catch"](32);
          _didIteratorError4 = true;
          _iteratorError4 = _context3.t1;

        case 47:
          _context3.prev = 47;
          _context3.prev = 48;

          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }

        case 50:
          _context3.prev = 50;

          if (!_didIteratorError4) {
            _context3.next = 53;
            break;
          }

          throw _iteratorError4;

        case 53:
          return _context3.finish(50);

        case 54:
          return _context3.finish(47);

        case 55:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3, null, [[4, 17, 21, 29], [22,, 24, 28], [32, 43, 47, 55], [48,, 50, 54]]);
}

function groupby(iterable) {
  var keyFn,
      it,
      currentValue,
      currentKey,
      targetKey,
      grouper,
      nextVal,
      _args5 = arguments;
  return _regenerator["default"].wrap(function groupby$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          keyFn = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : _utils.primitiveIdentity;
          it = (0, _builtins.iter)(iterable);
          // $FlowFixMe - deliberate use of the SENTINEL symbol
          currentKey = SENTINEL;
          targetKey = currentKey;
          grouper =
          /*#__PURE__*/
          _regenerator["default"].mark(function grouper(tgtKey) {
            var nextVal;
            return _regenerator["default"].wrap(function grouper$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!(currentKey === tgtKey)) {
                      _context4.next = 10;
                      break;
                    }

                    _context4.next = 3;
                    return currentValue;

                  case 3:
                    nextVal = it.next();

                    if (!nextVal.done) {
                      _context4.next = 6;
                      break;
                    }

                    return _context4.abrupt("return");

                  case 6:
                    currentValue = nextVal.value; // eslint-disable-line require-atomic-updates

                    currentKey = keyFn(currentValue); // eslint-disable-line require-atomic-updates

                    _context4.next = 0;
                    break;

                  case 10:
                  case "end":
                    return _context4.stop();
                }
              }
            }, grouper);
          });

        case 5:
          if (!(currentKey === targetKey)) {
            _context5.next = 14;
            break;
          }

          nextVal = it.next();

          if (!nextVal.done) {
            _context5.next = 10;
            break;
          }

          // $FlowFixMe - deliberate use of the SENTINEL symbol
          currentKey = SENTINEL;
          return _context5.abrupt("return");

        case 10:
          currentValue = nextVal.value;
          currentKey = keyFn(currentValue);
          _context5.next = 5;
          break;

        case 14:
          targetKey = currentKey;
          _context5.next = 17;
          return [currentKey, grouper(targetKey)];

        case 17:
          _context5.next = 5;
          break;

        case 19:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked4);
}
/**
 * Returns an iterator that filters elements from data returning only those
 * that have a corresponding element in selectors that evaluates to `true`.
 * Stops when either the data or selectors iterables has been exhausted.
 */


function icompress(data, selectors) {
  var _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step6, _step6$value, d, s;

  return _regenerator["default"].wrap(function icompress$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _iteratorNormalCompletion5 = true;
          _didIteratorError5 = false;
          _iteratorError5 = undefined;
          _context6.prev = 3;
          _iterator5 = izip(data, selectors)[Symbol.iterator]();

        case 5:
          if (_iteratorNormalCompletion5 = (_step6 = _iterator5.next()).done) {
            _context6.next = 13;
            break;
          }

          _step6$value = _slicedToArray(_step6.value, 2), d = _step6$value[0], s = _step6$value[1];

          if (!s) {
            _context6.next = 10;
            break;
          }

          _context6.next = 10;
          return d;

        case 10:
          _iteratorNormalCompletion5 = true;
          _context6.next = 5;
          break;

        case 13:
          _context6.next = 19;
          break;

        case 15:
          _context6.prev = 15;
          _context6.t0 = _context6["catch"](3);
          _didIteratorError5 = true;
          _iteratorError5 = _context6.t0;

        case 19:
          _context6.prev = 19;
          _context6.prev = 20;

          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }

        case 22:
          _context6.prev = 22;

          if (!_didIteratorError5) {
            _context6.next = 25;
            break;
          }

          throw _iteratorError5;

        case 25:
          return _context6.finish(22);

        case 26:
          return _context6.finish(19);

        case 27:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked5, null, [[3, 15, 19, 27], [20,, 22, 26]]);
}
/**
 * Returns an iterator that filters elements from iterable returning only those
 * for which the predicate is true.
 */


function ifilter(iterable, predicate) {
  var _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step7, value;

  return _regenerator["default"].wrap(function ifilter$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          _iteratorNormalCompletion6 = true;
          _didIteratorError6 = false;
          _iteratorError6 = undefined;
          _context7.prev = 3;
          _iterator6 = iterable[Symbol.iterator]();

        case 5:
          if (_iteratorNormalCompletion6 = (_step7 = _iterator6.next()).done) {
            _context7.next = 13;
            break;
          }

          value = _step7.value;

          if (!predicate(value)) {
            _context7.next = 10;
            break;
          }

          _context7.next = 10;
          return value;

        case 10:
          _iteratorNormalCompletion6 = true;
          _context7.next = 5;
          break;

        case 13:
          _context7.next = 19;
          break;

        case 15:
          _context7.prev = 15;
          _context7.t0 = _context7["catch"](3);
          _didIteratorError6 = true;
          _iteratorError6 = _context7.t0;

        case 19:
          _context7.prev = 19;
          _context7.prev = 20;

          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }

        case 22:
          _context7.prev = 22;

          if (!_didIteratorError6) {
            _context7.next = 25;
            break;
          }

          throw _iteratorError6;

        case 25:
          return _context7.finish(22);

        case 26:
          return _context7.finish(19);

        case 27:
        case "end":
          return _context7.stop();
      }
    }
  }, _marked6, null, [[3, 15, 19, 27], [20,, 22, 26]]);
}
/**
 * Returns an iterator that computes the given mapper function using arguments
 * from each of the iterables.
 */


function imap(iterable, mapper) {
  var _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step8, value;

  return _regenerator["default"].wrap(function imap$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _iteratorNormalCompletion7 = true;
          _didIteratorError7 = false;
          _iteratorError7 = undefined;
          _context8.prev = 3;
          _iterator7 = iterable[Symbol.iterator]();

        case 5:
          if (_iteratorNormalCompletion7 = (_step8 = _iterator7.next()).done) {
            _context8.next = 12;
            break;
          }

          value = _step8.value;
          _context8.next = 9;
          return mapper(value);

        case 9:
          _iteratorNormalCompletion7 = true;
          _context8.next = 5;
          break;

        case 12:
          _context8.next = 18;
          break;

        case 14:
          _context8.prev = 14;
          _context8.t0 = _context8["catch"](3);
          _didIteratorError7 = true;
          _iteratorError7 = _context8.t0;

        case 18:
          _context8.prev = 18;
          _context8.prev = 19;

          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
            _iterator7["return"]();
          }

        case 21:
          _context8.prev = 21;

          if (!_didIteratorError7) {
            _context8.next = 24;
            break;
          }

          throw _iteratorError7;

        case 24:
          return _context8.finish(21);

        case 25:
          return _context8.finish(18);

        case 26:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked7, null, [[3, 14, 18, 26], [19,, 21, 25]]);
}
/**
 * Returns an iterator that returns selected elements from the iterable.  If
 * `start` is non-zero, then elements from the iterable are skipped until start
 * is reached.  Then, elements are returned by making steps of `step` (defaults
 * to 1).  If set to higher than 1, items will be skipped.  If `stop` is
 * provided, then iteration continues until the iterator reached that index,
 * otherwise, the iterable will be fully exhausted.  `islice()` does not
 * support negative values for `start`, `stop`, or `step`.
 */


function islice(iterable, start, stop) {
  var step,
      pred,
      _iteratorNormalCompletion8,
      _didIteratorError8,
      _iteratorError8,
      _iterator8,
      _step9,
      _step9$value,
      i,
      value,
      _args9 = arguments;

  return _regenerator["default"].wrap(function islice$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          step = _args9.length > 3 && _args9[3] !== undefined ? _args9[3] : 1;

          if (!(start < 0)) {
            _context9.next = 3;
            break;
          }

          throw new Error('start cannot be negative');

        case 3:
          if (!(typeof stop === 'number' && stop < 0)) {
            _context9.next = 5;
            break;
          }

          throw new Error('stop cannot be negative');

        case 5:
          if (!(step < 0)) {
            _context9.next = 7;
            break;
          }

          throw new Error('step cannot be negative');

        case 7:
          pred = slicePredicate(start, stop, step);
          _iteratorNormalCompletion8 = true;
          _didIteratorError8 = false;
          _iteratorError8 = undefined;
          _context9.prev = 11;
          _iterator8 = (0, _builtins.enumerate)(iterable)[Symbol.iterator]();

        case 13:
          if (_iteratorNormalCompletion8 = (_step9 = _iterator8.next()).done) {
            _context9.next = 21;
            break;
          }

          _step9$value = _slicedToArray(_step9.value, 2), i = _step9$value[0], value = _step9$value[1];

          if (!pred(i)) {
            _context9.next = 18;
            break;
          }

          _context9.next = 18;
          return value;

        case 18:
          _iteratorNormalCompletion8 = true;
          _context9.next = 13;
          break;

        case 21:
          _context9.next = 27;
          break;

        case 23:
          _context9.prev = 23;
          _context9.t0 = _context9["catch"](11);
          _didIteratorError8 = true;
          _iteratorError8 = _context9.t0;

        case 27:
          _context9.prev = 27;
          _context9.prev = 28;

          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }

        case 30:
          _context9.prev = 30;

          if (!_didIteratorError8) {
            _context9.next = 33;
            break;
          }

          throw _iteratorError8;

        case 33:
          return _context9.finish(30);

        case 34:
          return _context9.finish(27);

        case 35:
        case "end":
          return _context9.stop();
      }
    }
  }, _marked8, null, [[11, 23, 27, 35], [28,, 30, 34]]);
}
/**
 * Returns an iterator that aggregates elements from each of the iterables.
 * Used for lock-step iteration over several iterables at a time.  When
 * iterating over two iterables, use `izip2`.  When iterating over three
 * iterables, use `izip3`, etc.  `izip` is an alias for `izip2`.
 */


function izip2(xs, ys) {
  var ixs, iys, x, y;
  return _regenerator["default"].wrap(function izip2$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          ixs = (0, _builtins.iter)(xs);
          iys = (0, _builtins.iter)(ys);

        case 2:
          x = ixs.next();
          y = iys.next();

          if (!(!x.done && !y.done)) {
            _context10.next = 9;
            break;
          }

          _context10.next = 7;
          return [x.value, y.value];

        case 7:
          _context10.next = 10;
          break;

        case 9:
          return _context10.abrupt("return");

        case 10:
          _context10.next = 2;
          break;

        case 12:
        case "end":
          return _context10.stop();
      }
    }
  }, _marked9);
}
/**
 * Like izip2, but for three input iterables.
 */


function izip3(xs, ys, zs) {
  var ixs, iys, izs, x, y, z;
  return _regenerator["default"].wrap(function izip3$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          ixs = (0, _builtins.iter)(xs);
          iys = (0, _builtins.iter)(ys);
          izs = (0, _builtins.iter)(zs);

        case 3:
          x = ixs.next();
          y = iys.next();
          z = izs.next();

          if (!(!x.done && !y.done && !z.done)) {
            _context11.next = 11;
            break;
          }

          _context11.next = 9;
          return [x.value, y.value, z.value];

        case 9:
          _context11.next = 12;
          break;

        case 11:
          return _context11.abrupt("return");

        case 12:
          _context11.next = 3;
          break;

        case 14:
        case "end":
          return _context11.stop();
      }
    }
  }, _marked10);
}

var izip = izip2;
/**
 * Returns an iterator that aggregates elements from each of the iterables.  If
 * the iterables are of uneven length, missing values are filled-in with
 * fillvalue.  Iteration continues until the longest iterable is exhausted.
 */

exports.izip = izip;

function izipLongest2(xs, ys) {
  var filler,
      ixs,
      iys,
      x,
      y,
      _args12 = arguments;
  return _regenerator["default"].wrap(function izipLongest2$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          filler = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : undefined;
          ixs = (0, _builtins.iter)(xs);
          iys = (0, _builtins.iter)(ys);

        case 3:
          x = ixs.next();
          y = iys.next();

          if (!(x.done && y.done)) {
            _context12.next = 9;
            break;
          }

          return _context12.abrupt("return");

        case 9:
          _context12.next = 11;
          return [!x.done ? x.value : filler, !y.done ? y.value : filler];

        case 11:
          _context12.next = 3;
          break;

        case 13:
        case "end":
          return _context12.stop();
      }
    }
  }, _marked11);
}
/**
 * See izipLongest2, but for three.
 */


function izipLongest3(xs, ys, zs) {
  var filler,
      ixs,
      iys,
      izs,
      x,
      y,
      z,
      _args13 = arguments;
  return _regenerator["default"].wrap(function izipLongest3$(_context13) {
    while (1) {
      switch (_context13.prev = _context13.next) {
        case 0:
          filler = _args13.length > 3 && _args13[3] !== undefined ? _args13[3] : undefined;
          ixs = (0, _builtins.iter)(xs);
          iys = (0, _builtins.iter)(ys);
          izs = (0, _builtins.iter)(zs);

        case 4:
          x = ixs.next();
          y = iys.next();
          z = izs.next();

          if (!(x.done && y.done && z.done)) {
            _context13.next = 11;
            break;
          }

          return _context13.abrupt("return");

        case 11:
          _context13.next = 13;
          return [!x.done ? x.value : filler, !y.done ? y.value : filler, !z.done ? z.value : filler];

        case 13:
          _context13.next = 4;
          break;

        case 15:
        case "end":
          return _context13.stop();
      }
    }
  }, _marked12);
}
/**
 * Like the other izips (`izip`, `izip3`, etc), but generalized to take an
 * unlimited amount of input iterables.  Think `izip(*iterables)` in Python.
 *
 * **Note:** Due to Flow type system limitations, you can only "generially" zip
 * iterables with homogeneous types, so you cannot mix types like <A, B> like
 * you can with izip2().
 */


function izipMany() {
  var _len2,
      iters,
      _key2,
      iterables,
      heads,
      _args14 = arguments;

  return _regenerator["default"].wrap(function izipMany$(_context14) {
    while (1) {
      switch (_context14.prev = _context14.next) {
        case 0:
          for (_len2 = _args14.length, iters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            iters[_key2] = _args14[_key2];
          }

          // Make them all iterables
          iterables = iters.map(_builtins.iter);

        case 2:
          heads = iterables.map(function (xs) {
            return xs.next();
          });

          if (!(0, _builtins.all)(heads, function (h) {
            return !h.done;
          })) {
            _context14.next = 8;
            break;
          }

          _context14.next = 6;
          return heads.map(function (h) {
            return h.value;
          });

        case 6:
          _context14.next = 9;
          break;

        case 8:
          return _context14.abrupt("return");

        case 9:
          _context14.next = 2;
          break;

        case 11:
        case "end":
          return _context14.stop();
      }
    }
  }, _marked13);
}
/**
 * Return successive `r`-length permutations of elements in the iterable.
 *
 * If `r` is not specified, then `r` defaults to the length of the iterable and
 * all possible full-length permutations are generated.
 *
 * Permutations are emitted in lexicographic sort order.  So, if the input
 * iterable is sorted, the permutation tuples will be produced in sorted order.
 *
 * Elements are treated as unique based on their position, not on their value.
 * So if the input elements are unique, there will be no repeat values in each
 * permutation.
 */


function permutations(iterable, r) {
  var pool, n, x, indices, cycles, poolgetter, cleanExit, _iteratorNormalCompletion9, _didIteratorError9, _iteratorError9, _iterator9, _step10, i, j, _ref2, p, q;

  return _regenerator["default"].wrap(function permutations$(_context15) {
    while (1) {
      switch (_context15.prev = _context15.next) {
        case 0:
          pool = Array.from(iterable);
          n = pool.length;
          x = r === undefined ? n : r;

          if (!(x > n)) {
            _context15.next = 5;
            break;
          }

          return _context15.abrupt("return");

        case 5:
          indices = Array.from((0, _builtins.range)(n));
          cycles = Array.from((0, _builtins.range)(n, n - x, -1));

          poolgetter = function poolgetter(i) {
            return pool[i];
          };

          _context15.next = 10;
          return indices.slice(0, x).map(poolgetter);

        case 10:
          if (!(n > 0)) {
            _context15.next = 54;
            break;
          }

          cleanExit = true;
          _iteratorNormalCompletion9 = true;
          _didIteratorError9 = false;
          _iteratorError9 = undefined;
          _context15.prev = 15;
          _iterator9 = (0, _builtins.range)(x - 1, -1, -1)[Symbol.iterator]();

        case 17:
          if (_iteratorNormalCompletion9 = (_step10 = _iterator9.next()).done) {
            _context15.next = 36;
            break;
          }

          i = _step10.value;
          cycles[i] -= 1;

          if (!(cycles[i] === 0)) {
            _context15.next = 25;
            break;
          }

          indices = indices.slice(0, i).concat(indices.slice(i + 1)).concat(indices.slice(i, i + 1));
          cycles[i] = n - i;
          _context15.next = 33;
          break;

        case 25:
          j = cycles[i];
          _ref2 = [indices[indices.length - j], indices[i]], p = _ref2[0], q = _ref2[1];
          indices[i] = p;
          indices[indices.length - j] = q;
          _context15.next = 31;
          return indices.slice(0, x).map(poolgetter);

        case 31:
          cleanExit = false;
          return _context15.abrupt("break", 36);

        case 33:
          _iteratorNormalCompletion9 = true;
          _context15.next = 17;
          break;

        case 36:
          _context15.next = 42;
          break;

        case 38:
          _context15.prev = 38;
          _context15.t0 = _context15["catch"](15);
          _didIteratorError9 = true;
          _iteratorError9 = _context15.t0;

        case 42:
          _context15.prev = 42;
          _context15.prev = 43;

          if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
            _iterator9["return"]();
          }

        case 45:
          _context15.prev = 45;

          if (!_didIteratorError9) {
            _context15.next = 48;
            break;
          }

          throw _iteratorError9;

        case 48:
          return _context15.finish(45);

        case 49:
          return _context15.finish(42);

        case 50:
          if (!cleanExit) {
            _context15.next = 52;
            break;
          }

          return _context15.abrupt("return");

        case 52:
          _context15.next = 10;
          break;

        case 54:
        case "end":
          return _context15.stop();
      }
    }
  }, _marked14, null, [[15, 38, 42, 50], [43,, 45, 49]]);
}
/**
 * Returns an iterator that produces values over and over again.  Runs
 * indefinitely unless the times argument is specified.
 */


function repeat(thing, times) {
  var _iteratorNormalCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step11, i;

  return _regenerator["default"].wrap(function repeat$(_context16) {
    while (1) {
      switch (_context16.prev = _context16.next) {
        case 0:
          if (!(times === undefined)) {
            _context16.next = 7;
            break;
          }

        case 1:
          _context16.next = 3;
          return thing;

        case 3:
          _context16.next = 1;
          break;

        case 5:
          _context16.next = 33;
          break;

        case 7:
          // eslint-disable-next-line no-unused-vars
          _iteratorNormalCompletion10 = true;
          _didIteratorError10 = false;
          _iteratorError10 = undefined;
          _context16.prev = 10;
          _iterator10 = (0, _builtins.range)(times)[Symbol.iterator]();

        case 12:
          if (_iteratorNormalCompletion10 = (_step11 = _iterator10.next()).done) {
            _context16.next = 19;
            break;
          }

          i = _step11.value;
          _context16.next = 16;
          return thing;

        case 16:
          _iteratorNormalCompletion10 = true;
          _context16.next = 12;
          break;

        case 19:
          _context16.next = 25;
          break;

        case 21:
          _context16.prev = 21;
          _context16.t0 = _context16["catch"](10);
          _didIteratorError10 = true;
          _iteratorError10 = _context16.t0;

        case 25:
          _context16.prev = 25;
          _context16.prev = 26;

          if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
            _iterator10["return"]();
          }

        case 28:
          _context16.prev = 28;

          if (!_didIteratorError10) {
            _context16.next = 31;
            break;
          }

          throw _iteratorError10;

        case 31:
          return _context16.finish(28);

        case 32:
          return _context16.finish(25);

        case 33:
        case "end":
          return _context16.stop();
      }
    }
  }, _marked15, null, [[10, 21, 25, 33], [26,, 28, 32]]);
}
/**
 * Returns an iterator that produces elements from the iterable as long as the
 * predicate is true.
 */


function takewhile(iterable, predicate) {
  var _iteratorNormalCompletion11, _didIteratorError11, _iteratorError11, _iterator11, _step12, value;

  return _regenerator["default"].wrap(function takewhile$(_context17) {
    while (1) {
      switch (_context17.prev = _context17.next) {
        case 0:
          _iteratorNormalCompletion11 = true;
          _didIteratorError11 = false;
          _iteratorError11 = undefined;
          _context17.prev = 3;
          _iterator11 = iterable[Symbol.iterator]();

        case 5:
          if (_iteratorNormalCompletion11 = (_step12 = _iterator11.next()).done) {
            _context17.next = 14;
            break;
          }

          value = _step12.value;

          if (predicate(value)) {
            _context17.next = 9;
            break;
          }

          return _context17.abrupt("return");

        case 9:
          _context17.next = 11;
          return value;

        case 11:
          _iteratorNormalCompletion11 = true;
          _context17.next = 5;
          break;

        case 14:
          _context17.next = 20;
          break;

        case 16:
          _context17.prev = 16;
          _context17.t0 = _context17["catch"](3);
          _didIteratorError11 = true;
          _iteratorError11 = _context17.t0;

        case 20:
          _context17.prev = 20;
          _context17.prev = 21;

          if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
            _iterator11["return"]();
          }

        case 23:
          _context17.prev = 23;

          if (!_didIteratorError11) {
            _context17.next = 26;
            break;
          }

          throw _iteratorError11;

        case 26:
          return _context17.finish(23);

        case 27:
          return _context17.finish(20);

        case 28:
        case "end":
          return _context17.stop();
      }
    }
  }, _marked16, null, [[3, 16, 20, 28], [21,, 23, 27]]);
}

function zipLongest2(xs, ys) {
  var filler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  return Array.from(izipLongest2(xs, ys, filler));
}

function zipLongest3(xs, ys, zs) {
  var filler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
  return Array.from(izipLongest3(xs, ys, zs, filler));
}

var izipLongest = izipLongest2;
exports.izipLongest = izipLongest;
var zipLongest = zipLongest2;
exports.zipLongest = zipLongest;

function zipMany() {
  return Array.from(izipMany.apply(void 0, arguments));
}