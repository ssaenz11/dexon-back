"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.chunked = chunked;
exports.flatten = flatten;
exports.intersperse = intersperse;
exports.itake = itake;
exports.pairwise = pairwise;
exports.partition = partition;
exports.roundrobin = roundrobin;
exports.heads = heads;
exports.take = take;
exports.uniqueEverseen = uniqueEverseen;
exports.uniqueJustseen = uniqueJustseen;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _builtins = require("./builtins");

var _itertools = require("./itertools");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _marked =
/*#__PURE__*/
_regenerator["default"].mark(chunked),
    _marked2 =
/*#__PURE__*/
_regenerator["default"].mark(flatten),
    _marked3 =
/*#__PURE__*/
_regenerator["default"].mark(itake),
    _marked4 =
/*#__PURE__*/
_regenerator["default"].mark(pairwise),
    _marked5 =
/*#__PURE__*/
_regenerator["default"].mark(roundrobin),
    _marked6 =
/*#__PURE__*/
_regenerator["default"].mark(heads),
    _marked7 =
/*#__PURE__*/
_regenerator["default"].mark(uniqueEverseen),
    _marked8 =
/*#__PURE__*/
_regenerator["default"].mark(uniqueJustseen);

/**
 * Break iterable into lists of length `size`:
 *
 *     [...chunked([1, 2, 3, 4, 5, 6], 3)]
 *     // [[1, 2, 3], [4, 5, 6]]
 *
 * If the length of iterable is not evenly divisible by `size`, the last returned
 * list will be shorter:
 *
 *     [...chunked([1, 2, 3, 4, 5, 6, 7, 8], 3)]
 *     // [[1, 2, 3], [4, 5, 6], [7, 8]]
 */
function chunked(iterable, size) {
  var it, r1, chunk, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, item;

  return _regenerator["default"].wrap(function chunked$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          it = (0, _builtins.iter)(iterable);
          r1 = it.next();

          if (!r1.done) {
            _context.next = 4;
            break;
          }

          return _context.abrupt("return");

        case 4:
          chunk = [r1.value];
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 8;
          _iterator = it[Symbol.iterator]();

        case 10:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 20;
            break;
          }

          item = _step.value;
          chunk.push(item);

          if (!(chunk.length === size)) {
            _context.next = 17;
            break;
          }

          _context.next = 16;
          return chunk;

        case 16:
          chunk = [];

        case 17:
          _iteratorNormalCompletion = true;
          _context.next = 10;
          break;

        case 20:
          _context.next = 26;
          break;

        case 22:
          _context.prev = 22;
          _context.t0 = _context["catch"](8);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 26:
          _context.prev = 26;
          _context.prev = 27;

          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }

        case 29:
          _context.prev = 29;

          if (!_didIteratorError) {
            _context.next = 32;
            break;
          }

          throw _iteratorError;

        case 32:
          return _context.finish(29);

        case 33:
          return _context.finish(26);

        case 34:
          if (!(chunk.length > 0)) {
            _context.next = 37;
            break;
          }

          _context.next = 37;
          return chunk;

        case 37:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[8, 22, 26, 34], [27,, 29, 33]]);
}
/**
 * Return an iterator flattening one level of nesting in a list of lists:
 *
 *     [...flatten([[0, 1], [2, 3]])]
 *     // [0, 1, 2, 3]
 *
 */


function flatten(iterableOfIterables) {
  var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, iterable, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, item;

  return _regenerator["default"].wrap(function flatten$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context2.prev = 3;
          _iterator2 = iterableOfIterables[Symbol.iterator]();

        case 5:
          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
            _context2.next = 36;
            break;
          }

          iterable = _step2.value;
          _iteratorNormalCompletion3 = true;
          _didIteratorError3 = false;
          _iteratorError3 = undefined;
          _context2.prev = 10;
          _iterator3 = iterable[Symbol.iterator]();

        case 12:
          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
            _context2.next = 19;
            break;
          }

          item = _step3.value;
          _context2.next = 16;
          return item;

        case 16:
          _iteratorNormalCompletion3 = true;
          _context2.next = 12;
          break;

        case 19:
          _context2.next = 25;
          break;

        case 21:
          _context2.prev = 21;
          _context2.t0 = _context2["catch"](10);
          _didIteratorError3 = true;
          _iteratorError3 = _context2.t0;

        case 25:
          _context2.prev = 25;
          _context2.prev = 26;

          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }

        case 28:
          _context2.prev = 28;

          if (!_didIteratorError3) {
            _context2.next = 31;
            break;
          }

          throw _iteratorError3;

        case 31:
          return _context2.finish(28);

        case 32:
          return _context2.finish(25);

        case 33:
          _iteratorNormalCompletion2 = true;
          _context2.next = 5;
          break;

        case 36:
          _context2.next = 42;
          break;

        case 38:
          _context2.prev = 38;
          _context2.t1 = _context2["catch"](3);
          _didIteratorError2 = true;
          _iteratorError2 = _context2.t1;

        case 42:
          _context2.prev = 42;
          _context2.prev = 43;

          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }

        case 45:
          _context2.prev = 45;

          if (!_didIteratorError2) {
            _context2.next = 48;
            break;
          }

          throw _iteratorError2;

        case 48:
          return _context2.finish(45);

        case 49:
          return _context2.finish(42);

        case 50:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, null, [[3, 38, 42, 50], [10, 21, 25, 33], [26,, 28, 32], [43,, 45, 49]]);
}
/**
 * Intersperse filler element `value` among the items in `iterable`.
 *
 *     >>> [...intersperse(-1, range(1, 5))]
 *     [1, -1, 2, -1, 3, -1, 4]
 *
 */


function intersperse(value, iterable) {
  var stream = flatten((0, _itertools.izip)((0, _itertools.repeat)(value), iterable));
  take(1, stream); // eat away and discard the first value from the output

  return stream;
}
/**
 * Returns an iterable containing only the first `n` elements of the given
 * iterable.
 */


function itake(n, iterable) {
  var it, count, s;
  return _regenerator["default"].wrap(function itake$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          it = (0, _builtins.iter)(iterable);
          count = n;

        case 2:
          if (!(count-- > 0)) {
            _context3.next = 12;
            break;
          }

          s = it.next();

          if (s.done) {
            _context3.next = 9;
            break;
          }

          _context3.next = 7;
          return s.value;

        case 7:
          _context3.next = 10;
          break;

        case 9:
          return _context3.abrupt("return");

        case 10:
          _context3.next = 2;
          break;

        case 12:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
}
/**
 * Returns an iterator of paired items, overlapping, from the original.  When
 * the input iterable has a finite number of items `n`, the outputted iterable
 * will have `n - 1` items.
 *
 *     >>> pairwise([8, 2, 0, 7])
 *     [(8, 2), (2, 0), (0, 7)]
 *
 */


function pairwise(iterable) {
  var it, r1, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, r2;

  return _regenerator["default"].wrap(function pairwise$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          it = (0, _builtins.iter)(iterable);
          r1 = it.next();

          if (!r1.done) {
            _context4.next = 4;
            break;
          }

          return _context4.abrupt("return");

        case 4:
          r1 = r1.value;
          _iteratorNormalCompletion4 = true;
          _didIteratorError4 = false;
          _iteratorError4 = undefined;
          _context4.prev = 8;
          _iterator4 = it[Symbol.iterator]();

        case 10:
          if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
            _context4.next = 18;
            break;
          }

          r2 = _step4.value;
          _context4.next = 14;
          return [r1, r2];

        case 14:
          r1 = r2;

        case 15:
          _iteratorNormalCompletion4 = true;
          _context4.next = 10;
          break;

        case 18:
          _context4.next = 24;
          break;

        case 20:
          _context4.prev = 20;
          _context4.t0 = _context4["catch"](8);
          _didIteratorError4 = true;
          _iteratorError4 = _context4.t0;

        case 24:
          _context4.prev = 24;
          _context4.prev = 25;

          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }

        case 27:
          _context4.prev = 27;

          if (!_didIteratorError4) {
            _context4.next = 30;
            break;
          }

          throw _iteratorError4;

        case 30:
          return _context4.finish(27);

        case 31:
          return _context4.finish(24);

        case 32:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, null, [[8, 20, 24, 32], [25,, 27, 31]]);
}
/**
 * Returns a 2-tuple of arrays.  Splits the elements in the input iterable into
 * either of the two arrays.  Will fully exhaust the input iterable.  The first
 * array contains all items that match the predicate, the second the rest:
 *
 *     >>> const isOdd = x => x % 2 !== 0;
 *     >>> const iterable = range(10);
 *     >>> const [odds, evens] = partition(iterable, isOdd);
 *     >>> odds
 *     [1, 3, 5, 7, 9]
 *     >>> evens
 *     [0, 2, 4, 6, 8]
 *
 */


function partition(iterable, predicate) {
  var good = [];
  var bad = [];
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = iterable[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var item = _step5.value;

      if (predicate(item)) {
        good.push(item);
      } else {
        bad.push(item);
      }
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
        _iterator5["return"]();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  return [good, bad];
}
/**
 * Yields the next item from each iterable in turn, alternating between them.
 * Continues until all items are exhausted.
 *
 *     >>> [...roundrobin([1, 2, 3], [4], [5, 6, 7, 8])]
 *     [1, 4, 5, 2, 6, 3, 7, 8]
 */


function roundrobin() {
  var _len,
      iters,
      _key,
      iterables,
      index,
      it,
      result,
      _args5 = arguments;

  return _regenerator["default"].wrap(function roundrobin$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          for (_len = _args5.length, iters = new Array(_len), _key = 0; _key < _len; _key++) {
            iters[_key] = _args5[_key];
          }

          // We'll only keep lazy versions of the input iterables in here that we'll
          // slowly going to exhaust.  Once an iterable is exhausted, it will be
          // removed from this list.  Once the entire list is empty, this algorithm
          // ends.
          iterables = (0, _builtins.map)(iters, _builtins.iter);

        case 2:
          if (!(iterables.length > 0)) {
            _context5.next = 18;
            break;
          }

          index = 0;

        case 4:
          if (!(index < iterables.length)) {
            _context5.next = 16;
            break;
          }

          it = iterables[index];
          result = it.next();

          if (result.done) {
            _context5.next = 13;
            break;
          }

          _context5.next = 10;
          return result.value;

        case 10:
          index++;
          _context5.next = 14;
          break;

        case 13:
          // This iterable is exhausted, make sure to remove it from the
          // list of iterables.  We'll splice the array from under our
          // feet, and NOT advancing the index counter.
          iterables.splice(index, 1); // intentional side-effect!

        case 14:
          _context5.next = 4;
          break;

        case 16:
          _context5.next = 2;
          break;

        case 18:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5);
}
/**
 * Yields the heads of all of the given iterables.  This is almost like
 * `roundrobin()`, except that the yielded outputs are grouped in to the
 * "rounds":
 *
 *     >>> [...heads([1, 2, 3], [4], [5, 6, 7, 8])]
 *     [[1, 4, 5], [2, 6], [3, 7], [8]]
 *
 * This is also different from `zipLongest()`, since the number of items in
 * each round can decrease over time, rather than being filled with a filler.
 */


function heads() {
  var _len2,
      iters,
      _key2,
      iterables,
      index,
      round,
      it,
      result,
      _args6 = arguments;

  return _regenerator["default"].wrap(function heads$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          for (_len2 = _args6.length, iters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            iters[_key2] = _args6[_key2];
          }

          // We'll only keep lazy versions of the input iterables in here that we'll
          // slowly going to exhaust.  Once an iterable is exhausted, it will be
          // removed from this list.  Once the entire list is empty, this algorithm
          // ends.
          iterables = (0, _builtins.map)(iters, _builtins.iter);

        case 2:
          if (!(iterables.length > 0)) {
            _context6.next = 11;
            break;
          }

          index = 0;
          round = [];

          while (index < iterables.length) {
            it = iterables[index];
            result = it.next();

            if (!result.done) {
              round.push(result.value);
              index++;
            } else {
              // This iterable is exhausted, make sure to remove it from the
              // list of iterables.  We'll splice the array from under our
              // feet, and NOT advancing the index counter.
              iterables.splice(index, 1); // intentional side-effect!
            }
          }

          if (!(round.length > 0)) {
            _context6.next = 9;
            break;
          }

          _context6.next = 9;
          return round;

        case 9:
          _context6.next = 2;
          break;

        case 11:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6);
}
/**
 * Non-lazy version of itake().
 */


function take(n, iterable) {
  return Array.from(itake(n, iterable));
}
/**
 * Yield unique elements, preserving order.
 *
 *     >>> [...uniqueEverseen('AAAABBBCCDAABBB')]
 *     ['A', 'B', 'C', 'D']
 *     >>> [...uniqueEverseen('AbBCcAB', s => s.toLowerCase())]
 *     ['A', 'b', 'C']
 *
 */


function uniqueEverseen(iterable) {
  var keyFn,
      seen,
      _iteratorNormalCompletion6,
      _didIteratorError6,
      _iteratorError6,
      _iterator6,
      _step6,
      item,
      key,
      _args7 = arguments;

  return _regenerator["default"].wrap(function uniqueEverseen$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          keyFn = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : _utils.primitiveIdentity;
          seen = new Set();
          _iteratorNormalCompletion6 = true;
          _didIteratorError6 = false;
          _iteratorError6 = undefined;
          _context7.prev = 5;
          _iterator6 = iterable[Symbol.iterator]();

        case 7:
          if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
            _context7.next = 17;
            break;
          }

          item = _step6.value;
          key = keyFn(item);

          if (seen.has(key)) {
            _context7.next = 14;
            break;
          }

          seen.add(key);
          _context7.next = 14;
          return item;

        case 14:
          _iteratorNormalCompletion6 = true;
          _context7.next = 7;
          break;

        case 17:
          _context7.next = 23;
          break;

        case 19:
          _context7.prev = 19;
          _context7.t0 = _context7["catch"](5);
          _didIteratorError6 = true;
          _iteratorError6 = _context7.t0;

        case 23:
          _context7.prev = 23;
          _context7.prev = 24;

          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }

        case 26:
          _context7.prev = 26;

          if (!_didIteratorError6) {
            _context7.next = 29;
            break;
          }

          throw _iteratorError6;

        case 29:
          return _context7.finish(26);

        case 30:
          return _context7.finish(23);

        case 31:
        case "end":
          return _context7.stop();
      }
    }
  }, _marked7, null, [[5, 19, 23, 31], [24,, 26, 30]]);
}
/**
 * Yields elements in order, ignoring serial duplicates.
 *
 *     >>> [...uniqueJustseen('AAAABBBCCDAABBB')]
 *     ['A', 'B', 'C', 'D', 'A', 'B']
 *     >>> [...uniqueJustseen('AbBCcAB', s => s.toLowerCase())]
 *     ['A', 'b', 'C', 'A', 'B']
 *
 */


function uniqueJustseen(iterable) {
  var keyFn,
      last,
      _iteratorNormalCompletion7,
      _didIteratorError7,
      _iteratorError7,
      _iterator7,
      _step7,
      item,
      key,
      _args8 = arguments;

  return _regenerator["default"].wrap(function uniqueJustseen$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          keyFn = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : _utils.primitiveIdentity;
          last = undefined;
          _iteratorNormalCompletion7 = true;
          _didIteratorError7 = false;
          _iteratorError7 = undefined;
          _context8.prev = 5;
          _iterator7 = iterable[Symbol.iterator]();

        case 7:
          if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {
            _context8.next = 17;
            break;
          }

          item = _step7.value;
          key = keyFn(item);

          if (!(key !== last)) {
            _context8.next = 14;
            break;
          }

          _context8.next = 13;
          return item;

        case 13:
          last = key;

        case 14:
          _iteratorNormalCompletion7 = true;
          _context8.next = 7;
          break;

        case 17:
          _context8.next = 23;
          break;

        case 19:
          _context8.prev = 19;
          _context8.t0 = _context8["catch"](5);
          _didIteratorError7 = true;
          _iteratorError7 = _context8.t0;

        case 23:
          _context8.prev = 23;
          _context8.prev = 24;

          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
            _iterator7["return"]();
          }

        case 26:
          _context8.prev = 26;

          if (!_didIteratorError7) {
            _context8.next = 29;
            break;
          }

          throw _iteratorError7;

        case 29:
          return _context8.finish(26);

        case 30:
          return _context8.finish(23);

        case 31:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked8, null, [[5, 19, 23, 31], [24,, 26, 30]]);
}