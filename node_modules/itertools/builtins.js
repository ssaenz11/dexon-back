"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.all = all;
exports.any = any;
exports.contains = contains;
exports.enumerate = enumerate;
exports.filter = filter;
exports.iter = iter;
exports.map = map;
exports.max = max;
exports.min = min;
exports.range = range;
exports.reduce = reduce;
exports.reduce_ = reduce_;
exports.sorted = sorted;
exports.sum = sum;
exports.zip = zip;
exports.zip3 = zip3;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _custom = require("./custom");

var _itertools = require("./itertools");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _marked =
/*#__PURE__*/
_regenerator["default"].mark(enumerate);

/**
 * Returns true when all of the items in iterable are truthy.  An optional key
 * function can be used to define what truthiness means for this specific
 * collection.
 *
 * Examples:
 *
 *     all([])                           // => true
 *     all([0])                          // => false
 *     all([0, 1, 2])                    // => false
 *     all([1, 2, 3])                    // => true
 *
 * Examples with using a key function:
 *
 *     all([2, 4, 6], n => n % 2 === 0)  // => true
 *     all([2, 4, 5], n => n % 2 === 0)  // => false
 *
 */
function all(iterable) {
  var keyFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _utils.identityPredicate;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var item = _step.value;

      if (!keyFn(item)) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return true;
}
/**
 * Returns true when any of the items in iterable are truthy.  An optional key
 * function can be used to define what truthiness means for this specific
 * collection.
 *
 * Examples:
 *
 *     any([])                           // => false
 *     any([0])                          // => false
 *     any([0, 1, null, undefined])      // => true
 *
 * Examples with using a key function:
 *
 *     any([1, 4, 5], n => n % 2 === 0)  // => true
 *     any([{name: 'Bob'}, {name: 'Alice'}], person => person.name.startsWith('C'))  // => false
 *
 */


function any(iterable) {
  var keyFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _utils.identityPredicate;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = iterable[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var item = _step2.value;

      if (keyFn(item)) {
        return true;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return false;
}
/**
 * Returns true when any of the items in the iterable are equal to the target object.
 *
 * Examples:
 *
 *     contains([], 'whatever')         // => false
 *     contains([3], 42)                // => false
 *     contains([3], 3)                 // => true
 *     contains([0, 1, 2], 2)           // => true
 *
 */


function contains(haystack, needle) {
  return any(haystack, function (x) {
    return x === needle;
  });
}
/**
 * Returns an iterable of enumeration pairs.  Iterable must be a sequence, an
 * iterator, or some other object which supports iteration.  The elements
 * produced by returns a tuple containing a counter value (starting from 0 by
 * default) and the values obtained from iterating over given iterable.
 *
 * Example:
 *
 *     import { enumerate } from 'itertools';
 *
 *     console.log([...enumerate(['hello', 'world'])]);
 *     // [0, 'hello'], [1, 'world']]
 */


function enumerate(iterable) {
  var start,
      index,
      _iteratorNormalCompletion3,
      _didIteratorError3,
      _iteratorError3,
      _iterator3,
      _step3,
      value,
      _args = arguments;

  return _regenerator["default"].wrap(function enumerate$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          start = _args.length > 1 && _args[1] !== undefined ? _args[1] : 0;
          index = start;
          _iteratorNormalCompletion3 = true;
          _didIteratorError3 = false;
          _iteratorError3 = undefined;
          _context.prev = 5;
          _iterator3 = iterable[Symbol.iterator]();

        case 7:
          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
            _context.next = 14;
            break;
          }

          value = _step3.value;
          _context.next = 11;
          return [index++, value];

        case 11:
          _iteratorNormalCompletion3 = true;
          _context.next = 7;
          break;

        case 14:
          _context.next = 20;
          break;

        case 16:
          _context.prev = 16;
          _context.t0 = _context["catch"](5);
          _didIteratorError3 = true;
          _iteratorError3 = _context.t0;

        case 20:
          _context.prev = 20;
          _context.prev = 21;

          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }

        case 23:
          _context.prev = 23;

          if (!_didIteratorError3) {
            _context.next = 26;
            break;
          }

          throw _iteratorError3;

        case 26:
          return _context.finish(23);

        case 27:
          return _context.finish(20);

        case 28:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[5, 16, 20, 28], [21,, 23, 27]]);
}
/**
 * Non-lazy version of ifilter().
 */


function filter(iterable, predicate) {
  return Array.from((0, _itertools.ifilter)(iterable, predicate));
}
/**
 * Returns an iterator object for the given iterable.  This can be used to
 * manually get an iterator for any iterable datastructure.  The purpose and
 * main use case of this function is to get a single iterator (a thing with
 * state, think of it as a "cursor") which can only be consumed once.
 */


function iter(iterable) {
  // TODO: Not sure why Flow choked on this expression below, but at least we lock down the
  // type transformation in the function signature this way.
  // $FlowFixMe
  return iterable[Symbol.iterator]();
}
/**
 * Non-lazy version of imap().
 */


function map(iterable, mapper) {
  return Array.from((0, _itertools.imap)(iterable, mapper));
}
/**
 * Return the largest item in an iterable.  Only works for numbers, as ordering
 * is pretty poorly defined on any other data type in JS.  The optional `keyFn`
 * argument specifies a one-argument ordering function like that used for
 * sorted().
 *
 * If the iterable is empty, `undefined` is returned.
 *
 * If multiple items are maximal, the function returns either one of them, but
 * which one is not defined.
 */


function max(iterable) {
  var keyFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _utils.numberIdentity;
  return reduce_(iterable, function (x, y) {
    return keyFn(x) > keyFn(y) ? x : y;
  });
}
/**
 * Return the smallest item in an iterable.  Only works for numbers, as
 * ordering is pretty poorly defined on any other data type in JS.  The
 * optional `keyFn` argument specifies a one-argument ordering function like
 * that used for sorted().
 *
 * If the iterable is empty, `undefined` is returned.
 *
 * If multiple items are minimal, the function returns either one of them, but
 * which one is not defined.
 */


function min(iterable) {
  var keyFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _utils.numberIdentity;
  return reduce_(iterable, function (x, y) {
    return keyFn(x) < keyFn(y) ? x : y;
  });
}
/**
 * Internal helper for the range function
 */


function _range(start, stop, step) {
  var counter = (0, _itertools.count)(start, step);
  var pred = step >= 0 ? function (n) {
    return n < stop;
  } : function (n) {
    return n > stop;
  };
  return (0, _itertools.takewhile)(counter, pred);
}
/**
 * Returns an iterator producing all the numbers in the given range one by one,
 * starting from `start` (default 0), as long as `i < stop`, in increments of
 * `step` (default 1).
 *
 * `range(a)` is a convenient shorthand for `range(0, a)`.
 *
 * Various valid invocations:
 *
 *     range(5)           // [0, 1, 2, 3, 4]
 *     range(2, 5)        // [2, 3, 4]
 *     range(0, 5, 2)     // [0, 2, 4]
 *     range(5, 0, -1)    // [5, 4, 3, 2, 1]
 *     range(-3)          // []
 *
 * For a positive `step`, the iterator will keep producing values `n` as long
 * as the stop condition `n < stop` is satisfied.
 *
 * For a negative `step`, the iterator will keep producing values `n` as long
 * as the stop condition `n > stop` is satisfied.
 *
 * The produced range will be empty if the first value to produce already does
 * not meet the value constraint.
 */


function range(a) {
  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var args = [a].concat(rest); // "a" was only used by Flow to make at least one value mandatory

  switch (args.length) {
    case 1:
      return _range(0, args[0], 1);

    case 2:
      return _range(args[0], args[1], 1);

    case 3:
      return _range(args[0], args[1], args[2]);

    /* istanbul ignore next */

    default:
      throw new Error('invalid number of arguments');
  }
}
/**
 * Apply function of two arguments cumulatively to the items of sequence, from
 * left to right, so as to reduce the sequence to a single value.  For example:
 *
 *     reduce([1, 2, 3, 4, 5], (x, y) => x + y, 0)
 *
 * calculates
 *
 *     (((((0+1)+2)+3)+4)+5)
 *
 * The left argument, `x`, is the accumulated value and the right argument,
 * `y`, is the update value from the sequence.
 *
 * **Difference between `reduce()` and `reduce\_()`**:  `reduce()` requires an
 * explicit initializer, whereas `reduce_()` will automatically use the first
 * item in the given iterable as the initializer.  When using `reduce()`, the
 * initializer value is placed before the items of the sequence in the
 * calculation, and serves as a default when the sequence is empty.  When using
 * `reduce_()`, and the given iterable is empty, then no default value can be
 * derived and `undefined` will be returned.
 */


function reduce(iterable, reducer, start) {
  var it = iter(iterable);
  var output = start;
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = enumerate(it)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var _step4$value = _slicedToArray(_step4.value, 2),
          index = _step4$value[0],
          item = _step4$value[1];

      output = reducer(output, item, index);
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return output;
}
/**
 * See reduce().
 */


function reduce_(iterable, reducer) {
  var it = iter(iterable);
  var start = (0, _custom.first)(it);

  if (start === undefined) {
    return undefined;
  } else {
    return reduce(it, reducer, start);
  }
}
/**
 * Return a new sorted list from the items in iterable.
 *
 * Has two optional arguments:
 *
 * * `keyFn` specifies a function of one argument providing a primitive
 *   identity for each element in the iterable.  that will be used to compare.
 *   The default value is to use a default identity function that is only
 *   defined for primitive types.
 *
 * * `reverse` is a boolean value.  If `true`, then the list elements are
 *   sorted as if each comparison were reversed.
 */


function sorted(iterable) {
  var keyFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _utils.primitiveIdentity;
  var reverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var result = Array.from(iterable);
  result.sort((0, _utils.keyToCmp)(keyFn)); // sort in-place

  if (reverse) {
    result.reverse(); // reverse in-place
  }

  return result;
}
/**
 * Sums the items of an iterable from left to right and returns the total.  The
 * sum will defaults to 0 if the iterable is empty.
 */


function sum(iterable) {
  return reduce(iterable, function (x, y) {
    return x + y;
  }, 0);
}
/**
 * See izip.
 */


function zip(xs, ys) {
  return Array.from((0, _itertools.izip)(xs, ys));
}
/**
 * See izip3.
 */


function zip3(xs, ys, zs) {
  return Array.from((0, _itertools.izip3)(xs, ys, zs));
}